---
layout: post
title: Step1. 깨끗한 코드
tags: CleanCode, Clean, Code
math: true
---

## 들어가기

> 여러분이 이책을 읽고 있다면 이유는 두 가지다.  
> 첫째, 프로그래머라서  
> 둘째, 더 나은 프로그래머가 되기 위해서  
> 그렇다면 다행이다. 우리 업계는 더 나은 프로그래머가 필요하기 때문이다.

## 목차

- [코드가 존재하리라](#1)
- [나쁜코드](#2)
- [나쁜 코드로 치르는 대가](#3)
  - [원대한 재설계의 꿈](#4)
  - [태도](#5)
  - [원초적 난재](#6)
  - [깨끗한 코드라는 예술?](#7)
- [깨끗한 코드란?](#8)
  - [비야네 스트롭스트롭](#9)
  - [그래디 부치](#10)
  - [큰 데이브 토마스](#11)
  - [마이클 페더스](#12)
  - [론 제프리스](#13)
  - [워드 커닝햄](#14)
- [우리는 저자다](#15)
- [보이스카우트 규칙](#16)
- [프리퀄과 원칙](#17)
- [정리](#18)
- [출저 및 참고문헌](#19)

<a name="1" />

## 코드가 존재하리라

- 코드를 다루는 책은 시대에 뒤떨어지는 주제이고, 명세 기준으로 프로그램이 자동으로 생성되는 것은 틀렸다.
  - 앞으로 코드가 사라질 가망은 전혀 없다. 이유는 코드는 요구사항을 상세히 표한하는 수단이라서!!
  - 앞으로 프로그래밍 언어에서 추상화 수준은 점차 높아질 것이다.
  - 코드로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이다.

<a name="2" />

## 나쁜코드

- 어느 한 업체가 킬러 앱(Killer App) 하나를 구현하였다.
  - 하지만 해당 앱을 만든 업체는 망하게 되었다.
  - 그 이유는 출시에 바빠서 코드를 마구 구현하였다고 한다.
  - 결국 회사가 망한 원인은 바로 나쁜 코드 때문이였다.
- 우리 모두 가 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각하고 그냥 넘어가는데,  
  결국 그 시간은 돌아오지 않는다. (르블랑의 법칙)

<a name="3" />

## 나쁜 코드로 치르는 대가

- 나쁜 코드가 쌓일수록 팀 생산성이 떨어진다

  - 생산성이 떨어지기 때문에 관리층은 나름 복구를 시도하기 위해 새로운 인력을 투입한다.
  - 새 인력팀은 생산성을 높여야 한다는 극심한 압력에 시달리고, 결국은 나쁜 코드를 더 많이 양상한다.
  - 결국엔 생산성은 더더욱 떨어져 거의 0이 된다.

<a name="4" />

## 원대한 재설계의 꿈

- 혐오스러운 코드로는 더 이상 일하지 못하겠다며 관리층에게 재설계를 요구한다.
- 새로운 타이거 팀이 구성된다.
- 가장 유능하고 똑똑한 사람들만 타이커 티임으로 차출되고, 나머지는 계속에서 현재 시스템을 유지보수 한다.
- 두 팀이 경주를 시작하는데, 타이거 팀은 기존 시스템 기능을 모두 제공하는 새 시스템을 내놓아야 하며,  
  또한 그동안 기존 시스템에 가해지는 변경도 모두 따라 잡야아한다.
- 새 시스템이 기존 시스템을 따라잡을 즈음이면 초창기 타이거 팀원들은 모두 팀을 떠났고 새로운 팀원들이 새 시스템을 설계하자고 나선다.
- 그 이유는, 현재 시스템이 너무 엉망이라서...
- 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길이다.

<a name="5" />

## 태도

- 코드가 엉망이라서 몇 시간으로 예상한 업무가 몇 주로 늘어진 경험이 있는가?
- 우리는 한 줄만 고치면 되리라 예상했던 것이 모듈을 수백개 건드린 경험이 있는가?
- 어째서 좋은 코드가 한 순간에 나쁜 코드로 전략해버린걸까?
  - 설계를 뒤집는 방향으로 요구사항이 변했다!
  - 일정이 촉박해서 제대로 하지 못했다!
- 위와 같은 변명 불문하고 결국엔 우리 프로그래머의 잘못이 크다...
- 무조건!! 우리는 좋은 코드를 사수해야만 한다!!
- 또한 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.

<a name="6" />

## 원초적 난재

- 나쁜 코드를 양산하면 기한을 맞추지 못한다.
- 기한을 맞추는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

<a name="7" />

## 깨끗한 코드라는 예술?

- 깨끗한 코드를 구현하는 행위는 그림을 그리는 행위와 비슷하다.
- 깨끗한 코드를 작성하려면 '청결'이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다.
- 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올려야한다.
- 깨끗한 코드를 작성하는 프로그래머는 빈 캔퍼스를 우아한 작품으로 바꿔가는 화가와 같다.

<a name="8" />

## 깨끗한 코드란?

<a name="9" />
> 비야네 스트롭스트롭

> 1. 우하하고 효율적인 코드를 좋아한다.
> 2. 철저한 오류 처리가 필요하다.
> 3. 논리가 간단해야 버그가 숨어들지 못한다.
> 4. 의존성을 최대한 줄여야 유지보수가 쉬워진다.
> 5. 깨끗한 코드는 한가지를 제대로 한다.

---

<a name="10" />
> 그래디 부치

> 1. 단순하고 직접적이다.
> 2. 잘 쓴 문장처럼 읽힌다.
> 3. 설계자의 의도를 숨기지 않는다.
> 4. 명쾌한 추상화와 단순한 제어문으로 가득하다.

---

<a name="11" />
> 큰 데이브 토마스

> 1. 작성자가 아닌 사람도 읽기 쉽고 고치기 쉬워야한다.
> 2. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. (테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.)
> 3. 의미 있는 이름이 붙는다.
> 4. 의존성은 최소이며 각 의존성을 명확히 정의한다.
> 5. API는 명확하며 최소로 줄인다.
> 6. 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.

---

<a name="12" />
> 마이클 페더스

> 1. 모두를 아우르는 특징이 있다.
> 2. 누군가 주의 깊게 짰다는 느낌을 준다.
> 3. 고치려고 살펴봐도 딱히 손 댈 곳이 없다.
> 4. 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.

---

<a name="13" />
> 론 제프리스

> 1. 모든 테스트를 통과한다.
> 2. 중복이 없다.
> 3. 시스템 내 모든 설계 아이디어를 표현한다.
> 4. 클래스, 메서드, 함수 등을 최대한 줄인다.
> 5. 메서드 추출 리펙터링 기법

---

<a name="14" />
> 워드 커닝햄

> 짐작했던 기능을 각 루틴이 그대로 수행하다면 깨끗한 코드다.  
> 그 문제를 풀기 위한 언어처럼 모인다면 아름다운 코드다.

---

<a name="15" />

## 우리는 저자다

```
밥이 모듈을 입력한다.
변경할 함수로 스크롤해 내려간다.
잠시 멈추고 생각한다.
이런! 모듈 상단으로 스크롤해 변수 초기화를 확인한다.
다시 내려와 입력하기 시작한다.
이런, 입력을 지운다!
다시 입력한다!
다시 지운다!
뭔가를 절반쯤 입력하다가 또 지운다!
지금 바꾸려는 함수를 호출하는 함수로 스크롤한 후 함수가 호출되는 방식을 살펴본다.
다시 돌아와 방금 지운 코드를 입력한다.
잠시 멈춘다.
코드를 다시 지운다.
다른 윈도를 열어 하위 클래스를 살핀다. 함수가 재정의되어있는가?
...
```

- 실제 코드를 짜는 시간보다 코드를 읽는 시간의 비율이 훨씬 크다.
- 주변 코드가 읽기 쉬우면 새 코드를 짜기도 쉽다.
- 서둘러 끝내려면, 쉽게 짜려면, 읽기 쉽게 만들어라.

<a name="16" />

## 보이스카우트 규칙

- 체크아웃할 떄보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다.
- 변수 이름을 하나를 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.

<a name="17" />

## 프리퀄과 원칙

- SRP : 클래스에는 한 가지, 단 한가지 변경 이유만 존재해야 한다.
- OCP : 클래스는 확장에 열려 있여야 하며, 변경에는 닫혀 있어야 한다.
- LSP : 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
- DIP : 추상화에 의존해야 하며, 구체와에 의존하면 안 된다.
- ISP : 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.

<a name="18" />

## 정리

- 깨끗한 코드를 만들기 위해선!! 연습!! 연습만이 살길이다!!

<a name="19" />

## 출저 및 참고문헌

- 클린코드 (애자일 소프트웨어 장인 정신)
